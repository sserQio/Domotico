Ultimo funzionante:

secondo argument obbligatorio

std::regex pattern(
    R"((set|rm|show|set time|reset time|reset timers|reset all)\s+)"   // Comando principale
    R"(\{(Impianto fotovoltaico|Pompa di calore \+ termostato|Scaldabagno|Frigorifero|Lavatrice|Lavastoviglie|Tapparelle elettriche|Forno a microonde|Asciugatrice|Televisore)\}\s*)" // Dispositivi
    R"((\{(on|off|(?:[01]\d|2[0-3]):[0-5]\d)\})?\s*)"               // Terzo argomento: {on}, {off}, o orario {hh:mm}
    R"((?:\{((?:[01]\d|2[0-3]):[0-5]\d)\})?)"                         // Quarto argomento: solo orario {hh:mm}
);

bool System::compare_devices(Device* a, Device* b){
    CP* cp_a = dynamic_cast<CP*>(a);
    CP* cp_b = dynamic_cast<CP*>(b);
    M* m_a = dynamic_cast<M*>(a);
    M* m_b = dynamic_cast<M*>(b);

    if (cp_a && cp_b){
        return (cp_a -> get_autoStart() + cp_a -> get_duration()) < (cp_b -> get_autoStart() + cp_b -> get_duration());
    }

    if (m_a && m_b){
        return m_a -> get_stop() < m_b -> get_stop();
    }

    if (m_a && cp_b){
        return m_a -> get_stop() < (cp_b -> get_autoStart() + cp_b -> get_duration());
    }

    if (m_b && cp_a){
        return m_b -> get_stop() < (cp_a -> get_autoStart() + cp_a -> get_duration());
    }

    return false;
}